# else( if)
### 단일 책임 원칙에 위배됨
 else가 들어가는 순간 분기에 따라 한 메서드가 2개 이상의 역할을 하게 됨 -> 수정 변경이 어려워짐
### 읽기 힘들다
```java
if(a){
}else if(b){
}else if(c){
}...
...
..
else
```
사이에 else if가 100개 있다고 가정해보자  

첫번째 if statement를 읽을 때는 a만 생각하면 된다. - 만약 a 라면, 아니면  
두번째는 a에 b를 얹어야 한다 - 만약 a가 아니고, b라면, b가 아니라면  
세번째는 a, b에 c를 얹어야 한다 - 만약 a가 아니고 b도 아니고, c라면, c가 아니라면  
..
이렇게 가면 코드를 읽는 사람은 **이전까지 모든 조건**과 **if문 안에 들어가는 로직**을 모두 기억하면서 읽어야 한다.  
**가독성은 clean code의 매우 중요한 지표중 하나**

## Then How?

### 일단 저 else 문을 지우는 것이 긍정적으로 보인다.
```java
if(a)
if(!a & b)
if(!a & !b & c)
..
```
조금 극단적인 예시지만 이런식으로 작성한다면 두가지 이점을 얻을 수 있다.  
1. 지금 접근한 if statement의 조건을 바로 확인하면 되고, 다른 if문에 관심을 둘 필요가 없다.
2. 만약 73번째 조건문이 변경되면 해당 if문만 고쳐주면 된다.

### 그럼에도 불구하고 현재 이 로직은 여러 역할을 하고 있다.
모든 if 문은 분기에 따라 다른 역할을 한다.  
이런 상황에서 다이어그램을 그려본다면 그리기 꽤나 힘들어질 것이다.  

### 각 if문 내부의 로직을 별도의 메서드를 판다면
현재 메서드의 역할을 '분기별 특정 역할 수행'에서 '분기별 알맞은 역할 호출'로 downgrade 시켜주는 것이다.  

1번 버스부터 100번 버스까지 버스기사 역할을 다 맡던 노동자를 터미널에서 표를 발행하는 키오스크로 탈바꿈시키고  
별도의 버스기사 100명을 고용하는 것이다.  

재사용성이 올라가는 효과도 기대될듯

# 다~중 for문(if문)
 - for iterator(조건식)를 중첩돼 갈 수록 기억해야 한다는 것
 - 상위 레벨 영역에서 사용된 변수 등의 상태값을 기억해야 함
즉, 복잡도가 올라간다.
